{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.1","compilation":{"directory":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7","program":"/Users/samv/.rustup/toolchains/nightly-x86_64-apple-darwin/bin/rls","arguments":["--crate-name","custom_derive","/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","--json=diagnostic-rendered-ansi,artifacts,future-incompat","--crate-type","lib","--emit=dep-info,metadata","-C","embed-bitcode=no","-C","split-debuginfo=unpacked","-C","debuginfo=2","--cfg","feature=\"std\"","-C","metadata=53a3c1ca8c7d6780","-C","extra-filename=-53a3c1ca8c7d6780","--out-dir","/Users/samv/uiowahack/geodesic_voronoi_tessallation/target/rls/debug/deps","-L","dependency=/Users/samv/uiowahack/geodesic_voronoi_tessallation/target/rls/debug/deps","--cap-lints","allow","--error-format=json","--sysroot","/Users/samv/.rustup/toolchains/nightly-x86_64-apple-darwin"],"output":"/Users/samv/uiowahack/geodesic_voronoi_tessallation/target/rls/debug/deps/libcustom_derive-53a3c1ca8c7d6780.rmeta"},"prelude":{"crate_id":{"name":"custom_derive","disambiguator":[4491925601196899201,0]},"crate_root":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src","external_crates":[{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[17848356123076402324,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[2571568952482378191,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[3381153973743375855,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[859990804154970231,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[13406540867394126232,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[8031689522704144356,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[7051263317280381750,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[15559094268889944187,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":9,"id":{"name":"miniz_oxide","disambiguator":[9861791662769261467,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[14233487050114319148,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":11,"id":{"name":"adler","disambiguator":[4193298229573560736,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":12,"id":{"name":"hashbrown","disambiguator":[15931660052351559034,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":13,"id":{"name":"std_detect","disambiguator":[762912116291214375,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":14,"id":{"name":"rustc_demangle","disambiguator":[16903055257668955945,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":15,"id":{"name":"addr2line","disambiguator":[561513094272624117,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":16,"id":{"name":"gimli","disambiguator":[59110909806878804,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":17,"id":{"name":"object","disambiguator":[2820196564566765046,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":18,"id":{"name":"memchr","disambiguator":[839392276863948394,0]}},{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","num":19,"id":{"name":"panic_unwind","disambiguator":[17041169231870870072,0]}}],"span":{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","byte_start":382,"byte_end":12792,"line_start":10,"line_end":462,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","byte_start":382,"byte_end":12792,"line_start":10,"line_end":462,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3}],"decl_id":null,"docs":"**Note**: This crate has been superseded by `macro-attr`.","sig":null,"attributes":[{"value":"*\n**Note**: This crate has been superseded by `macro-attr`.\n\nThis crate provides a macro that enables the use of custom `derive` attributes.\n\nTo use it, make sure you link to the crate like so:\n\n```rust\n#[macro_use] extern crate custom_derive;\n# macro_rules! Dummy { (() struct $name:ident;) => {}; }\n# custom_derive! { #[derive(Clone, Dummy)] struct Foo; }\n# fn main() { let _ = Foo; }\n```\n\n> **Note**: the `custom_derive!` macro itself is not documented, as the automatic documentation for it would be uselessly huge and incomprehensible.\n\n<style type=\"text/css\">\n.link-block { font-family: \"Fira Sans\"; }\n.link-block > p { display: inline-block; }\n.link-block > p > strong { font-weight: 500; margin-right: 1em; }\n.link-block > ul { display: inline-block; padding: 0; list-style: none; }\n.link-block > ul > li {\n  font-size: 0.8em;\n  background-color: #eee;\n  border: 1px solid #ccc;\n  padding: 0.3em;\n  display: inline-block;\n}\n</style>\n<span></span><div class=\"link-block\">\n\n**Links**\n\n* [Latest Release](https://crates.io/crates/custom_derive/)\n* [Latest Docs](https://docs.rs/crate/custom_derive/)\n* [Repository](https://github.com/DanielKeep/rust-custom-derive/tree/custom_derive-master/)\n\n<span></span></div>\n\n# Usage\n\nThe macro should be used to wrap an entire *single* `enum` or `struct` declaration, including its attributes (both `derive` and others).  All derivation attributes which the macro does *not* recognise will be assumed to be custom, and treated accordingly.\n\n`custom_derive!` assumes that custom derivations are implemented as macros (of the same name).  For example, here is a simple derivation macro:\n\n```rust\n#[macro_use] extern crate custom_derive;\n\ntrait TypeName {\n    fn type_name() -> &'static str;\n}\n\ntrait ReprType {\n    type Repr;\n}\n\nmacro_rules! TypeName {\n    (() $(pub)* enum $name:ident $($tail:tt)*) => { TypeName! { @impl $name } };\n    (() $(pub)* struct $name:ident $($tail:tt)*) => { TypeName! { @impl $name } };\n\n    (@impl $name:ident) => {\n        impl TypeName for $name {\n            fn type_name() -> &'static str { stringify!($name) }\n        }\n    };\n}\n\nmacro_rules! TryFrom {\n    (($repr:ty) $(pub)* enum $name:ident $($tail:tt)*) => {\n        impl ReprType for $name {\n            type Repr = $repr;\n        }\n    };\n}\n\ncustom_derive! {\n    #[allow(dead_code)]\n    #[repr(u8)]\n    #[derive(Clone, Copy, Debug, TryFrom(u8), TypeName)]\n    enum Foo { A, B }\n}\n\nfn main() {\n    let foo = Foo::B;\n    let v = foo as <Foo as ReprType>::Repr;\n    let msg = format!(\"{}: {:?} ({:?})\", Foo::type_name(), foo, v);\n    assert_eq!(msg, \"Foo: B (1)\");\n}\n```\n\nFirst, note that `custom_derive!` passes any arguments on the derivation attribute to the macro.  In the case of attributes *without* any arguments, `()` is passed instead.\n\nSecondly, the macro is passed the entire item, *sans* attributes.  It is the derivation macro's job to parse the item correctly.\n\nThird, each derivation macro is expected to result in zero or more items, not including the item itself.  As a result, it is *not* possible to mutate the item in any way, or attach additional attributes to it.\n\nFinally, `@impl` is merely a trick to pack multiple, different functions into a single macro.  The sequence has no special meaning; it is simply *distinct* from the usual invocation syntax.\n*/","span":{"file_name":"/Users/samv/.cargo/registry/src/github.com-1ecc6299db9ec823/custom_derive-0.1.7/src/lib.rs","byte_start":382,"byte_end":3694,"line_start":10,"line_end":107,"column_start":1,"column_end":3}}]}],"impls":[],"refs":[],"macro_refs":[],"relations":[]}